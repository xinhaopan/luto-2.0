\documentclass[12pt,a4paper,twoside]{article}

\usepackage[round]{natbib}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{comment}
\usepackage{authblk}
\usepackage{balance}
\usepackage[shortlabels]{enumitem}
\usepackage[parfill]{parskip}
\usepackage{appendix}
\usepackage{float}
\usepackage[labelfont=bf]{caption}
\usepackage{enumitem}
\usepackage{framed}
\usepackage{tcolorbox}
\usepackage{xfrac}
\usepackage{dirtree}
\usepackage{underscore}
\usepackage{setspace}
\usepackage{minted}
\usemintedstyle{trac}
\newminted{python}{fontsize=\scriptsize, linenos}
\usepackage{hyperref}
\floatstyle{boxed}
\restylefloat{figure}

\author[]{Fjalar~J~de~Haan\thanks{\textit{Corresponding author. Email:}fjalar@fjalar.org}}

\affil[]{Planet A, Centre for Integrative Ecology, \mbox{Deakin University, Australia}}

\date{}

\begin{document}

\title{LUTO II (neoLUTO)}

\maketitle

\tableofcontents

\newpage

\section{Introduction}
This document provides an overview of the software package of LUTO II\@. It describes its architecture, the mathematical model behind the cost-minimising dynamics, the data required and how to build them from the raw datasets. It also gives instructions on how to set up and run the model.

% more on luto pedigree

The LUTO II model simulates land-use change. The model is spatially explicit and the modelled territory is discretised into $1 \times 1$ km\textsuperscript{2} (approximately) grid cells. These grid cells are represented in the model as 1D arrays, with the array entry representing the land use. A \emph{land use} is, as the name suggests, the way land is used, which typically means what kind of crop is grown or what type of livestock grazes on it. Associated with the land use are production costs and yields, both annual, which allow the model to decide which land use is optimal for a cell. There is a list of land uses considered and these are represented by integer values (e.g. `Apples' $ = 1$, `Dairy' $ = 7$). Thus, at the heart of it, land-use change is modelled by a changing integer array. This integer array is called the land-use map or \emph{lumap} for short.

In addition to the land use, the model also takes into account \emph{land management}. Apples, for example, can be cultivated with (or without) irrigation, using organic methods (or not) and so on as well as combinations of such land managements. Depending on the land management, there will typically be different production costs and different yields associated with the land use. Irrigation is more expensive but may be expected to increase yields. There is a list of land managements and these are, like land uses, represented by integer values. Conventional, dry-land agriculture is the default and represented by zero, while irrigation is represented by one. The model currently only considers conventional dry land and irrigation as land managements. Thus there is also a land-management map, or \emph{lmmap} for short.

The \emph{lumap} and \emph{lmmap} are the dependent variables of the model. Everything else is calculated on the basis of these two 1D arrays. The mechanisms driving the dynamics are economic. In the original CSIRO LUTO, the economic rationale was profit maximisation, i.e.\ farmers were supposed to cultivate whatever would profit them most (subject to some risk-based thresholds). In LUTO II the economic rationale is more systemic. The idea is that the agricultural system tries to meet demands (inputs to the model) the best it can, subject to certain constraints, while trying to minimise the total cost of production. Thus, using a yearly time step, the model is fed new demands and the model's solver produces a new land-use map.

Minimising cost while meeting demand means the model is trading off the expenditure of production against the yield of the crop or livestock. In addition to this, there are \emph{transition costs} associated with switching from one land use to another. This means that if a grid cell changes from growing apples to raising cattle, there is not only the new production cost to be paid (which may be lower) but also a transition cost. These transition costs subsume various costs of switching (including infrastructural investments and changed irrigation costs). Transition costs introduce `memory' into the model, avoiding that the land-use map changes unrealistically much at each time step as it attempts to meet demand at lowest cost.

LUTO II, like its progenitor, is an optimisation model. The economic rationale is formalised as a linear programme, which is then solved using external, commercial, black-box, closed-source solver software (GUROBI for LUTO II and CPLEX for LUTO I). The mathematical model of LUTO II is an actual linear programme but an alternative solver prototype using binary decision variables is also part of the package.

The model is solved under various constraints. One constraint ensures that all of every cell is in use. That is, there is always \emph{some} land use on a cell and all of it is used. In principle, a cell can multiple `fractional' land uses, though in practice, if the territory consists of many cells this seems not to occur. Another constraint is that the deviation of production from the demanded quantities should be minimal. This is a so-called soft constraint. These two constraints are an essential part of the model formulation. The remaining constraints are concerned with environmental targets and they can be switched on or off. Of these, water use is the first considered and the only one currently implemented. The water constraint demands that current water use relative to the water yield (how much runs of) in a river region should not exceed the water use in 2010 relative to pre-European yields (which are estimated using 1985 data and assuming deeply-rooted vegetation). Water is implemented as a hard constraint.

\section{Architecture of the model}
The LUTO II software is contained in a Python 3 package. The package structure (see Figure \ref{fig:package}) is meant to reflect the different stages of the modelling process. The various sub packages live under a main package called \mintinline{python}{luto}. Thus there is a sub package concerned with the loading of data (\mintinline{python}{luto.data}), one with cost calculations (\mintinline{python}{luto.economics}) and so on. Each sub package typically contains several modules, each with several functions.

A small number of design principles has generally been adhered to, though not into the extreme. The most important were:
\begin{itemize}
	\item Avoiding global variables and avoiding statefullness. The only exception to this being the \mintinline{python}{luto.solvers.simulation} module which has the express purpose of keeping the state of a simulation.
	\item Avoiding object orientation where possible. The notable exception is again \mintinline{python}{luto.solvers.simulation} which uses a \mintinline{python}{class Data}.
	\item Functions should be \emph{pure}. This means that a function should return something, it should always return the same thing if given the same arguments and it should do nothing else (`no side effects'). Deviations from this principle are typically explicit (e.g.\ setters and functions to write to file).
	\item Dependencies should be few. Generally, the external dependencies are limited to Numpy and Pandas (almost everything uses these) and things like HDF5 libraries. Dependencies on other LUTO modules are used where unavoidable, e.g.\ in a module where many things come together. Again, in \mintinline{python}{luto.solvers.simulation} there are of course plenty of internal imports.
\end{itemize}

The user interface of the model is the \mintinline{python}{luto.solvers.simulation} module. Importing this module will implicitly load the \mintinline{python}{data} module. It will use the parameters set in the \mintinline{python}{luto.settings} module. At this point, those parameters are limited to directory locations and some settings relating to the water constraints. If all the requisite data is available where it should be (\texttt{input/} by default), this is sufficient to run the model. One can run `interactively', that is, from the prompt of a Python interpreter or call the functions of the \mintinline{python}{luto.solvers.simulation} module from a run script. Preparing the input data and setting up the model to run is discussed in Section~\ref{sec:running}.

\floatstyle{plain}
\restylefloat{figure}
\begin{figure}
\vbox{%
\dirtree{%
.1 /.
.2 \textbf{luto/} \DTcomment{main sub-package, i.e.\ `src'}.
	.3 \textbf{data/} \DTcomment{loading of inputs}.
		.4 __init__.py \DTcomment{actual data module}.
		.4 economic.py \DTcomment{data preparation functions}.
	.3 \textbf{economics/} \DTcomment{costs, yields and water calculations}.
		.4 cost.py \DTcomment{production cost functions}.
		.4 quantity.py \DTcomment{yield functions}.
		.4 transitions.py \DTcomment{transition cost functions}.
		.4 water.py \DTcomment{water use and yield functions}.
	.3 \textbf{reporting/} \DTcomment{derivative output calculations}.
	.3 \textbf{solvers/} \DTcomment{functions and interface to run model}.
		.4 simulation.py \DTcomment{interface module for running simulations}.
		.4 solvers.py \DTcomment{solver function calling GUROBI}.
		.4 stacksolver.py \DTcomment{alternative solver (toy model stage)}.
	.3 \textbf{tools/} \DTcomment{utility functions}.
		.4 __init__.py \DTcomment{various utility functions}.
		.4 compmap.py \DTcomment{cross-tabulation functions}.
		.4 highposgtiff.py \DTcomment{to write lumaps to geotiffs}.
		.4 plotmap.py \DTcomment{lumap viewer using matplotlib}.
		.4 write.py \DTcomment{write simulation output to files in a dir}.
	.3 settings.py \DTcomment{settings like file locations and parameters}.
.2 \textbf{input/} \DTcomment{*.npy, *.csv and *.hdf5 data files}.
.2 \textbf{output/} \DTcomment{model results, lumaps and lmmaps etc.}.
.2 \textbf{docs/} \DTcomment{documentation, including this file}.
}
}
\caption{Directory structure of LUTO II Python package.}
\label{fig:package}
\end{figure}

\subsection{Loading data (\mintinline{python}{luto.data})}\label{subsec:data}
The main idea behind the \mintinline{python}{luto.data} module is to have a namespace for all input data and parameters. For example, importing the module, by issuing
\begin{minted}{python}
import luto.data as data
\end{minted}
will make the list of land uses available as \mintinline{python}{data.LANDUSES}. Data is made available in three ways, (1) by reading the data directly from a file, typically a *.npy, *.csv or *.hdf5 file, by (2) post-processing data read from file to some extent, or (3) by defining variables in the code directly (i.e.\ `magic numbers'). This third option is obviously to be avoided and the only magic number is the starting year, 2010, which is added to the year index (zero-based) whenever an actual calendar year is required.

The \mintinline{python}{luto.data} module needs a number of input files to be present at the right place. See Section~\ref{sec:running} and in specific Section~\ref{subsec:dataprep} for more information on the data preparation.

The data in the files are used to \emph{infer} various parameters of the modelling problem. In other words, in principle, the code knows nothing about the particulars of the modelling problem under consideration. Things like the spatial extent (number of grid cells), the lists of land uses and land managements and so on, the model obtains from inspecting the data files. (More precisely, the data build script does this. See Section~\ref{subsec:dataprep}.) This has the obvious advantage that the model is not tied to a certain number of cells or a particular set of land uses.

There are complications to this picture. The most notable being the following. The list of \emph{land uses} (whatever lives on the land) is not the same as, and not in a one-one relation with, the list of \emph{products} those land uses yield. For example, `Sheep - natural land' (a land use) yields `SHEEP - NATURAL LAND MEAT' as well as `SHEEP - NATURAL LAND WOOL'. To complicate matters further, the list of \emph{commodities} that are demanded (the time series of which are a key input to the model) are not the same nor in a one-one relationshep with either the list of land uses or products. For example, the demand for wool is indifferent to whether the sheep grazed on natural or modified land. So, in the list of products there is just `sheep wool'.

To avoid confusion and force useful errors, the three lists (\mintinline{python}{data.LANDUSES}, \mintinline{python}{data.PRODUCTS}, \mintinline{python}{data.COMMODITIES}) use different cases (sentence, all upper and all lower case, respectively). Nevertheless, the lists are produced by inferring the list of land-uses from the agricultural data and a host of string manipulations. This is clearly error prone in light of future extensions. Moreover, the \emph{conversions} from e.g.\ land-use to product representation, which are necessary to set up the linear programme in the solver, employ conversion matrices. These matrices are defined in the \mintinline{python}{luto.data} module following the above logic.

The situation with the land-uses, products and commodities makes the \mintinline{python}{luto.data} module cluttered, hard to read and a potential source of future bugs. The schema can likely be simplified to just two lists and some processing could be factored out while other things can be turned into file reads. At the moment however, the module works and once loaded the complications are at any rate not so visible.

Since the model avoids global dependencies, the \mintinline{python}{luto.data} loaded module needs to be explicitly passed as an argument to all functions that need it. While this may appear as complicating things unnecessarily, there are two key advantages to this approach:
\begin{enumerate}
	\item Many functions would take very long to import if they had the \mintinline{python}{luto.data} module as a hard-coded dependency. Those functions are now fairly light weight.
	\item One can also pass a \emph{different} data object to those functions. For example, some small dummy object for testing purposes. The \mintinline{python}{luto.simulation} module makes extensive use of this possibility by creating derivative data objects with many grid cells masked out to save computational space and time (see Section~\ref{subsec:solvers}).
\end{enumerate}

The \mintinline{python}{luto.data} sub-package has several modules but only the \texttt{/__init__.py} is used to load it. The modules
\mintinline{python}{luto.data.spatial} and \mintinline{python}{luto.data.temporal} are legacy code. The \mintinline{python}{luto.data.economic} module, however, is used in the data preparation (see Section~\ref{subsec:dataprep}).

\subsection{Economic calculations (\mintinline{python}{luto.economics})}
The sub-package \mintinline{python}{luto.economics} is concerned with calculating the production costs, transition costs and yields related to the land uses. This sub-package also contains a module to calculate water uses and yields. All functions in these modules are pure and most require a data object as an argument.

The calculations in this sub-package are typically returned in a matrix format, including `matrices' with more than two indices. This is partially because it is the natural format from the perspective of the mathematical formulation and GUROBI solver API. It also enables the use of some linear algebra tools making for compacter code. This at the expense of a lot of matrices of various shapes in the model. To keep overview and avoid errors, the following convention were used: A matrix data type is denoted by a letter followed by an underscore and a list of indices, e.g. \mintinline{python}{c_mrj}. The letter relates to the quantity in question (here `cost') and the indices run over various ranges, depending on what the axis represents. See Table~\ref{tab:indices} for the constantly recurring indices and the sets they enumerate.
\begin{table}
\centering
\begin{tabular}{lllll}
Index   & Set         & Range                                                & Set in LUTO II                                           & Range in LUTO II                                     \\
$ r $ & Grid cells  & $7 \times 10^7$ &                                                          & \mintinline{python}{data.NCELLS}  \\
$ j $ & Land uses   & 28                                                   & \mintinline{python}{data.LANDUSES}    & \mintinline{python}{data.NLUS}    \\
$ m $ & Land man's   & 2                                                   & \mintinline{python}{data.LANDMANS}    & \mintinline{python}{data.NLMS}    \\
$ p $ & Products    & 32                                                   & \mintinline{python}{data.PRODUCTS}    & \mintinline{python}{data.NPRS}    \\
$ c $ & Commodities & 26                                                   & \mintinline{python}{data.COMMODITIES} & \mintinline{python}{data.NCMS}
\end{tabular}
\caption{Common indices for matrix-like quantities.}
\label{tab:indices}
\end{table}


\subsubsection{Production costs (\mintinline{python}{luto.economics.cost})}
A major part of the optimisation logic are the annual production costs, i.e.\ what it costs to have a certain crop or livestock on a particular grid cell. These costs depend not only on the land use, but also on spatial location as well as the land-management type (whether it is irrigated or not) and the year. The \mintinline{python}{cost} module provides several functions to calculate these annual production costs. Of these, \mintinline{python}{get_cost_matrices()} provides the costs in the matrix format used by the solver. The actual cost calculations are done in separate functions (\mintinline{python}{get_cost_crop()} and \mintinline{python}{get_cost_lvstk()}). If one wants just the production costs of a certain land use and land management combination in a certain year, there is the function \mintinline{python}{get_cost(data, lu, lm, year)}, which returns a 1D spatial array with the cost per grid cell.

Production costs of crops are computed as \emph{fixed} plus \emph{area} plus \emph{quantity} costs. The fixed costs in turn are the sum of fixed \emph{labour}, \emph{operational} and \emph{depreciation} costs. These component costs come from data and only few operations are involved in the computation of the total production cost. Additionally, if it concerns an irrigated crop, there are water costs which are the product of the volume of water required and the delivery costs.

A similar breakdown holds for livestock production costs, with some amendments. The quantity costs in the data are now given per head so multiplication by a `yield potential' (number of heads per hectare) is necessary. In the water costs, now drinking water also needs to be included (regardless of whether the pasture is irrigated or not).

\subsubsection{Transition costs (\mintinline{python}{luto.economics.transitions})}
The transition costs are the costs of changing the land-use or land-management on a certain cell. The key function in this module is \mintinline{python}{get_transition_matrices()} which returns the transition matrices in a $t_{mrj}$ format. Thus the entry $t_{1, 3, 7}$ is the cost of switching cell number 3 (which is the fourth cell, arrays are zero based) to land use 7 (`Grapes') under land management 1 (`irr', i.e.\ irrigation). The knowledge about what the land-use and land-management it is switching \emph{from} is subsumed in the $t_{mrj}$ matrix, so naturally the current lumap and lmmap are arguments to the \mintinline{python}{get_transition_matrices()} function.

The actual transition costs are computed from a number of parts:
\begin{enumerate}
	\item `Raw' transition costs from one land use to another
	\item The difference in water licence costs after and before
	\item Irrigation infrastructure costs, if applicable
	\item Foregone income at 3 times the annual production costs
\end{enumerate}

Finally, the costs are amortised at 5\% with a horizon of 30 years.

\subsubsection{Yields (\mintinline{python}{luto.economics.quantity})}

Yields refer to the quantities of \emph{product} that can be obtained from a land use on a certain grid cell. While a land use has only one associated production cost, it can have several associated yields --- for example, as mentioned before, a land use like `Sheep - natural land' yields `SHEEP - NATURAL LAND MEAT' as well as `SHEEP - NATURAL LAND WOOL'.

The functions in the \mintinline{python}{luto.economics.quantity} module are parallel to their counterparts in the \mintinline{python}{costs} module --- with the crucial distinction that costs are for land uses, while yields pertain to products. Thus the module features the following functions. \mintinline{python}{get_quantity_matrices()} provides the yields in the matrix format used by the solver. The actual yield calculations are done in separate functions (\mintinline{python}{get_quantity_crop()} and \mintinline{python}{get_quantity_lvstk()}). If one wants just the yields of a certain product and land management combination in a certain year, there is the function \mintinline{python}{get_quantity(data, pr, lm, year)}, which returns a 1D spatial array with the cost per grid cell.

The yields for crops come directly from the input data and are only converted from per hectare to per cell units (in \mintinline{python}{get_quantity_crop()}). Also, for crops the correspondence between land uses and products is one-one. The calculations for livestock (in \mintinline{python}{get_quantity_lvstk()}) yields are a bit more involved and will be discussed below. The function \mintinline{python}{get_quantity()}, which branches to the before mentioned functions, additionally applies two multipliers, (1) the climate change impacts (via \mintinline{python}{get_ccimpact()}, interpolating input data) and (2) yield increases, i.e.\ productivity increases (directly from data).

The function \mintinline{python}{get_quantity_lvstk()} first infers which livestock and vegetation type are involved by calling the function \mintinline{python}{lvs_veg_types()} which determines this based on the product string. So, `SHEEP - NATURAL LAND WOOL' corresponds to livestock type `SHEEP' and vegetation type `NATL' (i.e.\ natural). This information is then used to calculate a \emph{yield potential} using the function \mintinline{python}{get_yield_pot()} which effectively is how many heads per hectare can be yielded.

The livestock yield data holds both the total herd size and the fraction available for use (e.g.\ slaughter or export). The product of these to factors gives a per-head, per-hectare yield. Thus \mintinline{python}{get_quantity_lvstk()} multiplies this by the yield potential and converts from per-hectare to per-cell units.

\subsection{Solving and running (\mintinline{python}{luto.solvers})}\label{subsec:solvers}

The heart of the model, that is, where the next land use map is actually computed is the \mintinline{python}{solve()} function --- `the solver' --- in the \mintinline{python}{luto.solvers.solver} module. This function takes all relevant input matrices, the demands, constraints and two conversion matrices as arguments and returns the new land-use and land-man' maps. Since this function solves the system for one time step at a time and a considerable list of arguments is required, there is an interface to solving the model provided in \mintinline{python}{luto.solvers.simulation}. The \mintinline{python}{simulation} module takes care of computing the input matrices, keeps track of the solved lumaps and lmmaps and provides a number of convenience functions. Section~\ref{sec:running} describes in some detail how to use the \mintinline{python}{simulation} module.

\subsubsection{The solver (\mintinline{python}{luto.solvers.solver})}

The full signature of the \mintinline{python}{solve()} function is:

\begin{minted}{python}
def solve( t_mrj  # Transition cost matrices.
         , c_mrj  # Production cost matrices.
         , q_mrp  # Yield matrices (n.b.\ `p' index not `j').
         , d_c    # Demands (n.b.\ `c' index not `j').
         , p      # Penalty factor.
         , x_mrj  # Exclude matrices.
         , lu2pr_pj # Conversion matrix: land-use to product(s).
         , pr2cm_cp # Conversion matrix: product(s) to commodity.
         , limits = None # Targets to use.
         , verbose = False # Print Gurobi output if True.
         )
\end{minted}

The first three arguments are the data matrices. Note the indexing convention indicating that these are 3D arrays, indexed by $m$ for the land-management (irrigation or dry land), $r$ for the grid cell number and either $j$ or $p$ for the land-use or product index. The \mintinline{python}{luto.economics} modules have functions that return these matrices in precisely the desired format. They are \mintinline{python}{get_transition_matrices()}, \mintinline{python}{get_cost_matrices()} and \mintinline{python}{get_quantity_matrices()}, respectively (in the appropriately named modules in the \mintinline{python}{luto.economics} sub package).

The fourth (`d_c') and fifth (`p') argument are the demands and the penalty factor, respectively. The demands need to be provided as a 1D array indexed by the commodities in \mintinline{python}{data.COMMODITIES} in lexicographic order. The penalty factor penalises over- and under production. The size of the penalty is the maximum (across the spatial domain) cost per tonne deviation from demand of a commodity times the penalty factor. Setting the penalty factor higher will urge the solver to try harder to meet demands exactly. Penalty factors of the order of 100 or 1000 were typical in testing situations.

The sixth argument, `x_mrj', is obtained using a \mintinline{python}{get_to_ag_exclude_matrices()} function, which can be found in the \mintinline{python}{luto.economics.transitions} module. The exclude matrices do what their name suggests, the tell the solver which cells cannot have certain land-use and land-management combinations. These exclusions are implemented consisely by making the upper bounds of the decision variables equal to the corresponding values (either zero or one) in the exclude matrices. Thus, if a cell---land-use---land-man combination is disallowed, its upper bound is equal to its lower bound is equal to zero. Testing suggests that the GUROBI solver, then, disregards these decision variables altogether, possibly giving some performance gain.

The seventh (`lu2pr_pj') and eighth (`pr2cm_cp') arguments are conversion matrices. What is converted is `vectors' of quantities of agricultural `stuff' from one representation (land-use, product or commodity) to another. The \mintinline{python}{lu2pr_pj} matrix is used to convert `vectors' of land-uses ($j$-index) to `vectors' of products ($p$-index). The \mintinline{python}{pr2cm_cp} matrix is used to convert `vectors' of products ($p$-index) to `vectors' of commodities ($c$-index). The conversion is by way of matrix multiplication. For example, if \mintinline{python}{v_j} are quantities in land-use representation, then \mintinline{python}{v_p = lu2pr_pj @ v_j} (the `\mintinline{python}{@}' denoting Python matrix multiplication) gives the quantities in the product representation (hence the $p$-index). These matrices are vailable from the \mintinline{python}{luto.data} module as \mintinline{python}{data.LU2PR} and \mintinline{python}{data.PR2CM}. These mappings between representations are not one-to-one so these matrices are \emph{not} invertible (they are not even square).

The ninth argument, `limits', asks for a dictionary of the environmental limits to include in the solving process. If \mintinline{python}{None} is passed, the solver just solves without any environmental constraints. The only environmental constraint currently implemented is water use. To use water constraints, pass a limits dictionary with an appropriate value set under the key `water'. The format of the limits for water can be inferred from the \mintinline{python}{simulation.get_limits()} method. One can set the limits per catchment (`river region').

Water limits are calculated by comparing the water use (from irrigation and drinking water) divided by a water yield (how much still runs off into the catchment with a reference fraction --- the base fraction. The limits dictionary should provide, for each catchment, the base fraction (which is not to be exceeded) and the use and yield matrices in $u_{mrj}$ and $y_{mrj}$ format, respectively. These matrices and the base fraction can be obtained from the \mintinline{python}{luto.economics.water} module via the \mintinline{python}{get_water_stress()} and \mintinline{python}{get_water_basefrac()} functions. These functions accept masks as arguments to tailor their outputs to the appropriate catchment.

The tenth and last argument, the `verbose' option, switches whether the GUROBI solver output is printed to the terminal. If set to \mintinline{python}{False} (the default) the solver (that is, \mintinline{python}{solve()}) will still print relevant information to the terminal (what year is being solved etc.)

Apart from the complications of the conversions between representations discussed above, the solver is a relatively straightforward implementation of the linear programme discussed in Section~\ref{sec:mathematics}. It should be noted that the decision variables (split out explicitly as a `dryland' and `irrigated' set) are continuous. This means that, in principle, fractional allocation of land uses is possible. In other words, it is technically possible that a cell is $\frac{4}{7}$ apples and $\frac{3}{7}$ sugarcane. For larger lumaps (in the order of thousands of cells or more) this does not seem to occur much anymore. The solver, in fact, \emph{flattens} the lumap before returning it so any fractional allocations are not detectable in the output lumap anymore. However, the decision variables are also returned for inspection, if one is interested.

\emph{The stacksolver}
An alternative solver is provided in the module \mintinline{python}{luto.solvers.stacksolver}. This module contains a \mintinline{python}{solver()} function very much like the one described above. The difference is the way in which it deals with the land-managements. This solver is only a proof-of-principle toy model and the module is self contained. The stacksolver can be run using the provide function \mintinline{python}{runstack_random()} which runs it with random number entries for the various input matrices. One passes it the size of the problem (how many cells, how many land uses) as well as the penalty factor and it returns the lumap and lmmap.

The stacksolver was written to circumvent a scaling problem with the normal solver. The way the normal solver is set up involves making a set of decision variables and accompanying data matrices for every \emph{combination} of land managements. This quickly gets too computationally and memory intense. The stacksolver instead introduces a set of binary decision variables for each new land management and computes the associated costs and yields of every combination adding up the \emph{increments} each land management would entail. This scales much more favourably in the number of land managements.

\subsubsection{Spatial coarse graining and spatial sub-setting}

\emph{Resfactor (lossy)}

To facilitate faster testing, one can run the model in a `coarse-grained' fashion. The idea is simply to present the solver with a sampled subset of the spatial domain and correspondingly sliced matrices. This facility is called `resfactor' after a similar functionality in LUTO I. The sampling can be either linear or quadratic, which means that if a sampling rate of $n$ is given, either every $n$\textsuperscript{th} or every $n \times n$\textsuperscript{th} cell is included. The linear mode produces sampling artefacts, so the quadratic mode should always be used. The sampling is implemented with a multiplicative mask. The following three functions are involved in recovering the maps from the coarse-grained solver output: \mintinline{python}{simulation.uncourse1D()}, \mintinline{python}{simulation.uncourse2D()} and \mintinline{python}{simulation.uncoursify()}.

Thought the resfactor can be set manually with the \mintinline{python}{simulation.set_resfactor()} function, for consistent settings it is recommended to instead pass the resfactor as an argument to \mintinline{python}{simulation.run()}.

The speed up is slightly better than proportional to the fraction of cells sampled. It should be superfluous to note that solving a coarse-grained map and then resizing the outputs does not provide the same results as an actual solve on the full map. Simulation results obtained with spatial coarse graining are to be used for quick inspections and sense checking in testing contexts only.

\emph{Subsetting (lossless)}

Since the grid cells with land use `Non-agricultural land' are not changed by the solver, there is no loss in solving the lumap with these cells excluded and reinserting them afterwards. This is precisely what is done when the solving is done using the \mintinline{python}{luto.solvers.simulation} interface. Like the spatial coarse graining, the sub-setting of the input map is achieved with a multiplicative map. In fact, when coarse graining is on, the two masks are indeed multiplied. The removed cells are re-inserted post-solve by the \mintinline{python}{simulation.reconstitute()} function. The speed up is proportional to the fraction of `Non-agricultural land' cells in the lumap and there is no loss of accuracy as there is no approximation.

Not only the lumap and lmmap are spatially explicit and therefore amenable to this sort of sub-setting or coarse-graining. In fact, many of the input data are spatially explicit and calculations could be sped up considerably if e.g.\ costs and yields were computed on the same fraction of the cells as the lumap and lmmap. The functions in the \mintinline{python}{luto.economics} module are agnostic to the spatial extent and pure, so if they were passed a data object on a different, smaller, spatial domain, they would not mind.

\emph{The} \mintinline{python}{class Data}

To make use of this, the \mintinline{python}{luto.solvers.simulation} module contains a class definition for a data object that can be spatially subsetted. This is a simple class with no methods. All it aims to do is to expose the same fields (at any rate the upper-case fields) as the \mintinline{python}{luto.data} module but defined on the masked spatial domain. To achieve this, it copies all the upper-case fields and applies the combined (multiplied) masks of resfactor and the lossless subsetting described earlier to the spatial fields.

For convenience, the \mintinline{python}{luto.solvers.simulation} module has four local getter methods to get the current production cost, yield or transition cost matrices (\mintinline{python}{get_c_mrj()}, \mintinline{python}{get_q_mrp()}, \mintinline{python}{get_t_mrj()} and \mintinline{python}{get_x_mrj()} respectively). These getter take no arguments and exploit the state kept in the \mintinline{python}{luto.solvers.simulation} to ensure the right data object, base and target years and coarse-graining multipliers are used. The \mintinline{python}{simulation.step()} and thus \mintinline{python}{simulation.run()} methods call these local matrix getters.

\subsubsection{Stepping and running using the simulation module}\label{subsubsec:steprun}

\emph{The} \mintinline{python}{simulation.step()} \emph{method}

To call the solver, the \mintinline{python}{luto.solvers.simulation} module uses a stepper function called \mintinline{python}{simulation.step()}. This is a simple wrapper around a call to the solver. It synchronises the simulation module (Which makes sure the right matrices are used), it undoes the effects of spatial coarse graining and subsetting whenever relevant and stores the outputs in the right places.

The synchronisation is achieved with a call to the \mintinline{python}{simulation.sync_years()} function. This function wants the \emph{base} and \emph{target} years as arguments. The base year is the year from which the lumap and lmmap are used. The target year is the year that is solved for. The supporting data, e.g.\ the cost and yield matrices, from the year before the target year are used. This is because there are year-dependent multipliers (e.g.\ yield increases) that act on the data. Thus, if the base year is 2010 and the target year is 2011, then the lumap and lmmap as well as the supporting data of 2010 will be used as the starting point. If the base year is 2010 and the target year is 2030, then the lumap and lmmap of 2010 are used with the supporting data of 2029. The \mintinline{python}{simulation.sync_years()} function synchronises those years across the module and instantiates a new \mintinline{python}{Data} object. This object takes into account any coarse graining and subsetting as discussed earlier. Note that the coarse graining (resfactor) has to be set seperately. Either by calling \mintinline{python}{simulation.set_resfactor()} or by providing it as an argument to the \mintinline{python}{simulation.run()} function --- this latter option is to be preferred.

The \mintinline{python}{simulation.step()} method places the solved maps in dictionaries called \mintinline{python}{simulation.lumaps} and \mintinline{python}{simulation.lmmaps} both of which use the calendar years as keys. When first loaded, the \mintinline{python}{luto.solvers.simulation} automatically places the lumap and lmmap from the \mintinline{python}{luto.data} module in the dictionary under the starting year set in \mintinline{python}{data.YR_CAL_BASE}, which is 2010 by default. Similarly the shapes (i.e.\ the spatial extents) as well as the decision variables are stored in dictionaries (again with years as keys) called \mintinline{python}{shapes} and \mintinline{python}{dvars}, respectively.

In addition to the base and target year, two additional arguments need to be passed to the \mintinline{python}{simulation.step()} method: the demands and the penalty factor. The stepper wants the demands and the penalty factor in the same format as the solver itself, see above for the details.

\emph{The} \mintinline{python}{simulation.run()} \emph{method}

The \mintinline{python}{simulation.step()} method is really only for internal or testing use. Actual simulations should be carried out with the \mintinline{python}{simulation.run()} method. The full signature with some explanatory comments is:

\begin{minted}{python}
def run( base               # Base year.
       , target             # Target year.
       , demands            # Demands, 1D or 2D array.
       , penalty            # Penalty factor.
       , style='sequential' # Solve target year or all years.
       , resfactor=False    # Coarse graining factor (quadratic).
       , verbose=False      # Whether to print GUROBI output.
       )
\end{minted}

The `base', `target' and `penalty' arguments are like explained for the \mintinline{python}{simulation.step()} method. The coarse graining factor can be set here using the \mintinline{python}{resfactor=...} option. If it is set to \mintinline{python}{False}, coarse graining is bypassed altogether. If one fills out, e.g.\ \mintinline{python}{resfactor=3}, each $3 \times 3$ square is treated as a single grid cell. The `verbose' option switches whether the GUROBI solver output is printed to the terminal, it is passed directly to the solver.

An important switch is the \mintinline{python}{style=...} option. If this is set \mintinline{python}{style='direct'} only the target year will be solved for. That is, one output lumap and one lmmap will be produced. If \mintinline{python}{style='sequential'}, however, all intermediate years are also solved and each subsequent year takes the previous output map as its basis. To match these options, the demands can be passed either as a 1D, commodity indexed, array (see \mintinline{python}{simulation.step()} above) or as a 2D time series --- i.e.\ a stacked array of 1D demand arrays. The shape of a 2D time series demands array is \mintinline{python}{(number_of_years, number_of_commodities)}. If \mintinline{python}{simulation.run()} is given a time series demands array but \mintinline{python}{style='direct'} is set, then the appropriate entry in the 2D array will be chosen automatically. Thus, if a demand time series is provided, one can run either `direct' or `sequential' style runs. If a 1D demand array is provided, one can only run `direct' style.

\newpage
\section{Optimisation mathematics}\label{sec:mathematics}

This section describes the linear programme at the heart of the solver. However, the formulae in the following are not \emph{precisely} what is implemented in code. Differences to keep in mind are:
\begin{itemize}
	\item The equations in Section~\ref{subsec:cbwevc} do not explicitly mention the land managements. That is, the $m$-index is not used. One can just think of the set of land uses to be twice as large, with every land use occuring once as a dryland and once as an irrigated version. (Indeed, an earlier implementation treated irrigated land uses like this.)
	\item The complications regarding land-uses, products and commodities (see Section\ref{subsec:data}) are completely ignored.
	\item Not all constraints in Sections~\ref{subsec:cbwevc} and~\ref{subsec:cbwslm} are implemented and all environmental constraints are ignored in Section~\ref{subsec:comparison}.
\end{itemize}

This section first presents the linear programme that is actually implemented (Section~\ref{subsec:cbwevc}). Then the stacksolver mathematical programme is presented (Section~\ref{subsec:cbwslm}). Then a comparison is made between the two approaches (Section~\ref{subsec:comparison}).

\newpage

\subsection{Cost-Based With Environmental Constraints}\label{subsec:cbwevc}

\everymath{\displaystyle}
\begin{equation}
	{\setstretch{2}
	\begin{array}{l c}
	\text{Minimise} \quad & \sum_{r \in R, j \in J} c_{rj} x_{rj}
					+ \sum_{r \in R, j \in J} t_{rj} x_{rj}
					+ \sum_{j \in J} \Delta_j, \\

	\text{subject to} \quad
	& \sum_{j \in J} x_{rj}  = 1, \\
	& 0 \leq x_{rj} \leq 1, \\
	& \Delta_j \leq p_j (d_j - \sum_{r \in R} q_{rj} x_{rj}) \leq \Delta_j \quad (j \in J \backslash B), \\
	& \sum_{r \in C_c, j \in J} w_{rj} x_{rj} \leq \bar{w}_c, \\
	& \sum_{r \in C_c, j \in J} n_{rj} x_{rj} \leq \bar{n}_c, \\
	& \sum_{r \in R, j \in J} k_{rj} x_{rj} \leq \bar{k}, \\
	& \sum_{j \in B} b_{rj} x_{rj} \geq \bar{b}_j.

	\end{array}}
\end{equation}
\everymath{}

\textbf{Sets and indices:}
\begin{itemize}
	\item $R$ is the set of all cells, indexed by $r$.
	\item $C_c \subset R$ is the (sub) set of cells in catchment $C_c$, indexed by $r$. The $c$ run over all the catchments considered.
	\item $J$ is the set of all land uses, indexed by $j$.
	\item $B \subset J$ is the (sub) set of biodiversity land uses, indexed by $j$.
\end{itemize}

\textbf{Decision variables:}
\begin{itemize}
	\item $x_{rj}$ is the proportion of cell $r$ allocated to land-use $j$.
\end{itemize}

\textbf{Coefficients:}
\begin{itemize}
	\item $c_{rj}$ is the cost per cell of producing land use $j$ at cell $r$.
	\item $t_{rj}$ is the cost of switching cell $r$ to land use $j$ (this incorporates knowledge of the current land use).
	\item $\Delta_j$ is a dummy variable representing how much production deviates from demand. This because the deviation is an absolute value. See the corresponding constraints.
	\item $d_{j}$ is the demand for land use $j$.
	\item $p_j$ is a penalty factor representing the cost of producing a unit too much or too little of land use $j$. E.g.\ an export or import cost.
	\item $q_{rj}$ is the yield of land use $j$ at cell $r$.
	\item $w_{rj}$ is the water use by land use $j$ at cell $r$.
	\item $\bar{w}_c$ is the limit to water use in catchment $C_c$.
	\item $n_{rj}$ is the nutrient runoff from land use $j$ at cell $r$.
	\item $\bar{n}_c$ is the limit to nutrient runoffs in catchment $C_c$.
	\item $k_{rj}$ is the carbon emissions at cell $r$ for land use $j$.
	\item $\bar{k}$ is the carbon budget.
	\item $b_{rj}$ is the conversion factor from cell to the natural units of a land-use $j \in B$. For example, if the target for land-use $j$ is in tonnes, the factor measures how many tonnes would be yielded at cell $r$.
	\item $\bar{b}_j$. The target for land use $j \in B$ in the relevant units.
\end{itemize}

\newpage

\subsection{Cost-Based With Stackable Land-Managements}\label{subsec:cbwslm}

The same notation conventions are used as in Section\~ref{subsec:cbwevc} with the addition of the $m_{rj}$ decision variables representing the land managements.

\everymath{\displaystyle}
\begin{equation}
	{\setstretch{2}
	\begin{array}{l c}
	\text{Minimise} \quad & \sum_{r \in R, j \in J} c_{rj} x_{rj}
				    + \sum_{r \in R, j \in J} c'_{rj} m_{rj}
					+ \sum_{r \in R, j \in J} t_{rj} x_{rj}
					+ \sum_{j \in J} \Delta_j, \\

	\text{subject to} \quad
	& x_{rj}, m_{rj} \in \{0, 1\}, \\
	& \sum_{j \in J} x_{rj}  = 1, \\
	& m_{rj} - x_{rj} \leq 0, \\
	& \Delta_j \leq p_j (d_j - \sum_{r \in R} q_{rj} x_{rj}) \leq \Delta_j \quad (j \in J \backslash B), \\
	& \sum_{r \in C_c, j \in J} w_{rj} x_{rj} \leq \bar{w}_c, \\
	& \sum_{r \in C_c, j \in J} n_{rj} x_{rj} \leq \bar{n}_c, \\
	& \sum_{r \in R, j \in J} k_{rj} x_{rj} \leq \bar{k}, \\
	& \sum_{j \in B} b_{rj} x_{rj} \geq \bar{b}_j.

	\end{array}}
\end{equation}
\everymath{}

\newpage

\subsection{Two Ways to Include Land-Managements}\label{subsec:comparison}

1. Each land-man (indexed by $m$) has its own $rj$-indexed set of decision variables and accompanying cost data. Since a combination of land-mans is also a land-man, this grows as $2^m$ --- exponential in $m$.

\everymath{\displaystyle}
\begin{equation}
	{\setstretch{2}
	\begin{array}{l c}
	\text{Minimise} \quad & \sum_{m \in M, r \in R, j \in J} c_{mrj} x_{mrj}
					+ \sum_{r \in R, j \in J} t_{mrj} x_{mrj}
					+ \sum_{j \in J} \Delta_j, \\

	\text{subject to} \quad
	& 0 \leq x_{mrj} \leq 1, \\
	& \sum_{m \in M, j \in J} x_{mrj}  = 1, \\
	& \Delta_j \leq p_j (d_j - \sum_{m \in M, r \in R} q_{mrj} x_{mrj}) \leq \Delta_j.

	\end{array}}
\end{equation}
\everymath{}

2. Each land-man is represented by its own $rj$-indexed boolean decision variable. Combinations are now a matter of switching the relevant land-mans on or off. This grows linear in $m$.

\everymath{\displaystyle}
\begin{equation}
	{\setstretch{2}
	\begin{array}{l c}
	\text{Minimise} \quad &
	                  \sum_{r \in R, j \in J} c_{rj} x_{rj}
				    + \sum_{m \in M, r \in R, j \in J} c'_{mrj} x'_{mrj}
					\\
					\quad &
					+ \sum_{r \in R, j \in J} t_{rj} x_{rj}
					+ \sum_{m \in M, r \in R, j \in J} t'_{mrj} x'_{mrj}
					\\
					\quad &
					+ \sum_{j \in J} \Delta_j, \\

	\text{subject to} \quad
	& x_{rj}, x'_{mrj} \in \{0, 1\}, \\
	& \sum_{j \in J} x_{rj}  = 1, \\
	& x'_{mrj} - x_{rj} \leq 0, \\
	& \Delta_j \leq p_j (d_j - q_j) \leq \Delta_j, \\
	& \text{where } q_j = \sum_{r \in R} q_{rj} x_{rj}
	                    + \sum_{m \in M, r \in R} q'_{mrj} x'_{mrj}.
	\end{array}}
\end{equation}
\everymath{}

\section{Setting up and running the model}\label{sec:running}

This section aims to provide a step plan to setting up and running LUTO II from scratch. From scratch is understood as having access to the source (in which this documentation ought to be included) and to, at least, the raw input data. A Unix-like environment (i.e.\ bash) is assumed.

\subsection{Setting up the source code}

The LUTO II code is hosted on GitHub at \url{https://github.com/land-use-trade-offs}. The exact location of the repository may change but at the time of writing the url is \url{https://github.com/land-use-trade-offs/luto2-dev.git}. Thus to download the entire LUTO II package in a directory (inside the present working directory) called \mintinline{bash}{neoluto} issue:
\begin{minted}{bash}
git clone https://github.com/land-use-trade-offs/luto2-dev.git neoluto
\end{minted}
The directory \mintinline{bash}{neoluto} (or whatever other name was chosen) does not need to exist yet but if it exists it needs to be empty. Note that the LUTO II package contains a directory \mintinline{bash}{luto} so cloning into a directory also named \mintinline{bash}{luto} creates confusing paths. When this cloning has been successfully completed, the directory \mintinline{bash}{neoluto} contains the directory structure listed in Figure~\ref{fig:package} with some extra, licence-related, files and a readme and such.

In principle, nothing needs to be changed to the code or the directory structure. Once the input data is in place, the model can run.

\subsection{Building and copying the input data}\label{subsec:dataprep}

LUTO II needs the following files to be present:
\begin{itemize}
\setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}\setlength{\itemindent}{-.3cm}
	\item \mintinline{bash}{agec-crops-c9.hdf5}
	\item \mintinline{bash}{agec-lvstk-c9.hdf5}
	\item \mintinline{bash}{climate-change-impacts-rcp2p6.hdf5}
	\item \mintinline{bash}{climate-change-impacts-rcp4p5.hdf5}
	\item \mintinline{bash}{climate-change-impacts-rcp6p0.hdf5}
	\item \mintinline{bash}{climate-change-impacts-rcp8p5.hdf5}
	\item \mintinline{bash}{draindivs.hdf5}
	\item \mintinline{bash}{feed-req.npy}
	\item \mintinline{bash}{landuses.npy}
	\item \mintinline{bash}{lmmap.npy}
	\item \mintinline{bash}{lumap.npy}
	\item \mintinline{bash}{pasture-kg-dm-ha.npy}
	\item \mintinline{bash}{potential-irrigation-areas.npy}
	\item \mintinline{bash}{prec-over-175mm.npy}
	\item \mintinline{bash}{real-area.npy}
	\item \mintinline{bash}{rivregs.hdf5}
	\item \mintinline{bash}{safe-pur-modl.npy}
	\item \mintinline{bash}{safe-pur-natl.npy}
	\item \mintinline{bash}{tmatrix.npy}
	\item \mintinline{bash}{water-delivery-price.npy}
	\item \mintinline{bash}{water-licence-price.npy}
	\item \mintinline{bash}{water-yield-baselines.hdf5}
	\item \mintinline{bash}{x-mrj.npy}
	\item [] ---
	\item \mintinline{bash}{NLUM_2010-11_mask.tif}
	\item \mintinline{bash}{Water_yield_GCM-Ensemble_ssp245_2010-2100_DR_ML_HA_mean.h5}
	\item \mintinline{bash}{Water_yield_GCM-Ensemble_ssp245_2010-2100_SR_ML_HA_mean.h5}
	\item \mintinline{bash}{yieldincreases-bau2022.csv}
\end{itemize}
These input files are expected in \mintinline{bash}{input} directory but a different directory can be set in the \mintinline{bash}{settings.py} file. The files \emph{above} the dash can be copied into the \mintinline{bash}{input} directory if they are available pre-made. If they are not available they can be \emph{built} using the build script in \mintinline{bash}{luto/data/build.ipynb} (more on this below). The files \emph{under} the dash need to be available and copied in the \mintinline{bash}{input} directory directly.

Note that the yield-increases file is simply a CSV file with yearly multipliers. The `bau2022' label is because the model was being set up for a BAU run in 2022, a different name can be set in the \mintinline{bash}{luto.data} module that loads it. The RCP can be set in the \mintinline{bash}{settings.py} file but this only affects the choice of climate change impacts HDF5 file. If another RCP is chosen, one can change the accompanying water yield file name in the \mintinline{bash}{luto.data} module.

The format for the yield-increases CSV is the following: First row, each cell contains either 'dry' or 'irr'. Second row, each cell contains the product name --- \emph{not} the land-use name, multiple things may be yielded from a land use with different multipliers. (See the code of the \mintinline{python}{luto.data} module for how the product names are generated from the land-use names.) Product names are in all upper case. The first two rows are the headers which will be read in as a multi-indexed Pandas dataframe. Subsequent rows are the multipliers, the first one of those being all ones. See also Table~\ref{tab:yieldincreases}.

\begin{table}
\centering
\begin{tabular}{rrr}
dry    & dry                        & $\ldots$ \\
APPLES & BEEF - MODIFIED LAND LEXP  & \\
1      & 1                          & \\
1.00372497691957 & 1.00984498317271 & \\
$\vdots$      &                       & $\ddots$
\end{tabular}
\caption{Format of the yield-increases CSV file.}
\label{tab:yieldincreases}
\end{table}

To build the files listed \emph{above} the dash, one needs the raw data files and the build script (\mintinline{bash}{luto/data/build.ipynb}). The build script also provides information about the format the model expects the input data to have. One exception being the yield-increases CSV file. The raw data files required are:
\begin{itemize}
\setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}\setlength{\itemindent}{-.3cm}
	\item \mintinline{bash}{cell_LU_mapping.h5}
	\item \mintinline{bash}{cell_zones_df.h5}
	\item \mintinline{bash}{tmatrix-categories.csv}
	\item \mintinline{bash}{tmatrix-cat2lus.csv}
	\item \mintinline{bash}{cell_livestock_data.h5}
	\item \mintinline{bash}{SA2_crop_data.h5}
	\item \mintinline{bash}{cell_biophysical_df.h5}
	\item \mintinline{bash}{NLUM_SPREAD_LU_ID_Mapped_Concordance.h5}
	\item \mintinline{bash}{SA2_climate_damage_mult.h5}
\end{itemize}
One straightforward way to produce the required input files is to copy the build script into the same directory as the raw data files. Then simply run the script, for example by issuing:

\begin{minted}{bash}
ipython build.ipynb
\end{minted}
This produces all the required files above the dash (and a few others). Then simply move or copy the produced files into the \mintinline{bash}{input} directory.

\subsection{Running LUTO II}
When all the input files are present, the LUTO II model can be run. To do this, first start a Python interpreter in the root of the package (the directory into which the code was cloned, e.g.\ \mintinline{bash}{neoluto}).Then load the \mintinline{python}{simulation} module, for example, like this:
\begin{minted}{python}
import luto.simulation as sim
\end{minted}
See Section~\ref{subsubsec:steprun} for more on stepping and running with the \mintinline{python}{simulation} module. Assuming one has loaded a demand vector into a variable called \mintinline{python}{demands}, one can now do a targeted run for, say, 2030 by issuing:
\begin{minted}{python}
sim.run( 2010
       , 2030
       , demands
       , 1000
       , style='direct'
       , resfactor=False
       , verbose=True )
\end{minted}
This run uses 2010 as the base year, a penalty level of 1000, no spatial coarse graining and prints the GUROBI output to the terminal. If one wants a run from 2010 to 2030 including all intervening years, one can issue:
\begin{minted}{python}
sim.run( 2010
       , 2030
       , demands
       , 1000
       , style='sequential'
       , resfactor=False
       , verbose=True )
\end{minted}
Either way, now one can use \mintinline{python}{sim.info()} to see which output lumaps and lmmaps are now available. After a single targeted run, there should be two sets of maps (base and target), while a sequential run would yield target $-$ base $+1$ maps. A map can be inspected using \mintinline{python}{sim.show_map(year)} (the legend and colour scheme may not be correct).

The lumaps and lmmaps are stored in \mintinline{python}{sim.lumaps} and \mintinline{python}{lmmaps}, respectively. The \mintinline{python}{luto.tools.write} module provides a convenience function to extract the results for a specific target year and produce maps and statistics. To do this for the year 2030, issue:
\begin{minted}{python}
from luto.tools.write import write
write(sim.data, sim, 2030)
\end{minted}
Where for \mintinline{python}{sim.data} one can also pass the normal data module (if it is loaded). The results will then be written in a directory with the present date as the name (e.g.\ 20220224) in the root directory of the package. This directory contains the maps as well as some crosstabulations for testing.






\end{document}
